#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     drive_left_1,  tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     drive_left_2,  tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     drive_left_3,  tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     drive_right_1, tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     drive_right_2, tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     drive_right_3, tmotorTetrix, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define motor_max 100
#define motor_min -100

#define spd_elevator 100
#define spd_intake 100

#define auto_time_max 30000 //Milliseconds (time1) for duration of autonomous

#define backlash_prevention_time 50 //Milliseconds (time1) to turn back motors and prevent gear slop
#define spd_backlash 5 //Power with which to turn the motors during backlash prevention

#define FORWARD true
#define BACK false

#define LEFT true
#define RIGHT false

//All distances in inches
#define radius_wheel 1.4375
#define radius_turn 8 //The distance from the center of turning to the center of any given wheel
#define encoder_per_rot 1440

#define encoder_left drive_left_1 //===NOTE: these might not be the motors that have encoders in the final
#define encoder_right drive_right_1

task main()
{
	clearTimer(T1); //Used to time autonomous as a whole

	bool _auto_finished = false; //Can be used to end auto early

	while(time1[T1] < auto_time_max && !_auto_finished) {

	}

}


//Spins a motor in a direction with low power to prevent gear backlash
void preventBacklash(int *motor, bool direction) { //Direction: true = forward, false = backward
*motor = direction ? spd_backlash : -1 * spd_backlash; //I don't know if this will work... I've not used
	wait1Msec(backlash_prevention_time);
	*motor = 0;
}

void setMotors(int left, int right) {
	motor[drive_left_1] = left;
	motor[drive_left_2] = left;
	motor[drive_left_3] = left;
	motor[drive_left_1] = right;
	motor[drive_left_2] = right;
	motor[drive_left_3] = right;
}

//Move in a straight line
void driveAuto(int distance, int power) {
	//preventBacklash(!direction);
	if (power > motor_max) power = motor_max;
	if (power < motor_min) power = motor_min;

	int encoderTicks = (int) floor(distance * encoder_per_rot / (PI * radius_wheel * 2));

	//Reset encoder counters
	nMotorEncoder[encoder_left] = 0;
	nMotorEncoder[encoder_right] = 0;

	nMotorEncoderTarget[encoder_left] = encoderTicks;
	nMotorEncoderTarget[encoder_right] = encoderTicks;

	setMotors(power, power);

	while(nMotorRunState[encoder_left] != runStateIdle || nMotorRunState[encoder_right] != runStateIdle) {
		;
	}

	setMotors(0, 0);
}

void turnAuto(int degrees, int power, bool direction) {
	if (power > motor_max) power = motor_max;
	if (power < 0) power = 0;

	int encoderTicks = (int) floor(2 * radius_turn * degrees * encoder_per_rot / (360 * 2 * radius_wheel));

	//Reset encoder counters
	nMotorEncoder[encoder_left] = 0;
	nMotorEncoder[encoder_right] = 0;

	nMotorEncoderTarget[encoder_left] = encoderTicks;
	nMotorEncoderTarget[encoder_right] = encoderTicks;

	if (direction == LEFT) {
		setMotors(-1 * power, power);
		} else {
		setMotors(power, -1 * power);
	}

	while(nMotorRunState[encoder_left] != runStateIdle || nMotorRunState[encoder_right] != runStateIdle) {
		;
	}

	setMotors(0, 0);
}
